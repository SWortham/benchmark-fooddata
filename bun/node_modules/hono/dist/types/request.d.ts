import type { Input, InputToDataByTarget, ParamKeys, ParamKeyToRecord, RemoveQuestion, UndefinedIfHavingQuestion, ValidationTargets } from './types';
import type { BodyData } from './utils/body';
import type { Cookie } from './utils/cookie';
import type { UnionToIntersection } from './utils/types';
export declare class HonoRequest<P extends string = '/', I extends Input['out'] = {}> {
    raw: Request;
    private paramData;
    private validatedData;
    path: string;
    constructor(request: Request, path?: string, paramData?: Record<string, string> | undefined);
    param(key: RemoveQuestion<ParamKeys<P>>): UndefinedIfHavingQuestion<ParamKeys<P>>;
    param(): UnionToIntersection<ParamKeyToRecord<ParamKeys<P>>>;
    query(key: string): string | undefined;
    query(): Record<string, string>;
    queries(key: string): string[] | undefined;
    queries(): Record<string, string[]>;
    header(name: string): string | undefined;
    header(): Record<string, string>;
    cookie(key: string): string | undefined;
    cookie(): Cookie;
    parseBody(): Promise<BodyData>;
    json<T = any>(): Promise<T>;
    text(): Promise<string>;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
    formData(): Promise<FormData>;
    addValidatedData(target: keyof ValidationTargets, data: {}): void;
    valid<T extends keyof ValidationTargets = I extends Record<infer R, unknown> ? R extends keyof ValidationTargets ? R : never : never>(target: T): InputToDataByTarget<I, T>;
    valid(): never;
    get url(): string;
    get method(): string;
    get headers(): Headers;
    get redirect(): RequestRedirect;
    get body(): ReadableStream<Uint8Array> | null;
    get bodyUsed(): boolean;
    get cache(): RequestCache;
    get credentials(): RequestCredentials;
    get integrity(): string;
    get keepalive(): boolean;
    get mode(): RequestMode;
    get referrer(): string;
    get refererPolicy(): ReferrerPolicy;
    get signal(): AbortSignal;
}
