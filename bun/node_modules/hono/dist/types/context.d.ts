import { HonoRequest } from './request';
import type { TypedResponse } from './types';
import type { Env, NotFoundHandler, Input } from './types';
import type { CookieOptions } from './utils/cookie';
import type { StatusCode } from './utils/http-status';
import type { JSONValue } from './utils/types';
declare type Runtime = 'node' | 'deno' | 'bun' | 'workerd' | 'fastly' | 'edge-light' | 'lagon' | 'other';
declare type HeaderRecord = Record<string, string | string[]>;
declare type Data = string | ArrayBuffer | ReadableStream;
export interface ExecutionContext {
    waitUntil(promise: Promise<unknown>): void;
    passThroughOnException(): void;
}
export interface ContextVariableMap {
}
interface NewResponse {
    (data: Data | null, status?: StatusCode, headers?: HeaderRecord): Response;
    (data: Data | null, init?: ResponseInit): Response;
}
interface BodyRespond extends NewResponse {
}
interface TextRespond {
    (text: string, status?: StatusCode, headers?: HeaderRecord): Response;
    (text: string, init?: ResponseInit): Response;
}
interface JSONRespond {
    <T = JSONValue>(object: T, status?: StatusCode, headers?: HeaderRecord): Response;
    <T = JSONValue>(object: T, init?: ResponseInit): Response;
}
interface JSONTRespond {
    <T>(object: T extends JSONValue ? T : JSONValue, status?: StatusCode, headers?: HeaderRecord): TypedResponse<T extends JSONValue ? (JSONValue extends T ? never : T) : never>;
    <T>(object: T extends JSONValue ? T : JSONValue, init?: ResponseInit): TypedResponse<T extends JSONValue ? (JSONValue extends T ? never : T) : never>;
}
interface HTMLRespond {
    (html: string, status?: StatusCode, headers?: HeaderRecord): Response;
    (html: string, init?: ResponseInit): Response;
}
declare type GetVariable<K, E extends Env> = K extends keyof E['Variables'] ? E['Variables'][K] : K extends keyof ContextVariableMap ? ContextVariableMap[K] : unknown;
declare type ContextOptions<E extends Env> = {
    env: E['Bindings'];
    executionCtx?: FetchEvent | ExecutionContext | undefined;
    notFoundHandler?: NotFoundHandler<E>;
    path?: string;
    paramData?: Record<string, string>;
};
export declare class Context<E extends Env = any, P extends string = any, I extends Input = {}> {
    env: E['Bindings'];
    finalized: boolean;
    error: Error | undefined;
    private _req?;
    private _status;
    private _executionCtx;
    private _pretty;
    private _prettySpace;
    private _map;
    private _headers;
    private _preparedHeaders;
    private _res;
    private _path;
    private _paramData?;
    private rawRequest?;
    private notFoundHandler;
    constructor(req: Request, options?: ContextOptions<E>);
    get req(): HonoRequest<P, I['out']>;
    get event(): FetchEvent;
    get executionCtx(): ExecutionContext;
    get res(): Response;
    set res(_res: Response | undefined);
    header: (name: string, value: string, options?: {
        append?: boolean;
    }) => void;
    status: (status: StatusCode) => void;
    set: <Key extends keyof E["Variables"] | "jwtPayload">(key: Key, value: GetVariable<Key, E>) => void;
    get: <Key extends keyof E["Variables"] | "jwtPayload">(key: Key) => GetVariable<Key, E>;
    pretty: (prettyJSON: boolean, space?: number) => void;
    newResponse: NewResponse;
    body: BodyRespond;
    text: TextRespond;
    json: JSONRespond;
    jsonT: JSONTRespond;
    html: HTMLRespond;
    redirect: (location: string, status?: StatusCode) => Response;
    cookie: (name: string, value: string, opt?: CookieOptions) => void;
    notFound: () => Response | Promise<Response>;
    get runtime(): Runtime;
}
export {};
