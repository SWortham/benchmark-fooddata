"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var context_exports = {};
__export(context_exports, {
  Context: () => Context
});
module.exports = __toCommonJS(context_exports);
var import_request = require("./request");
var import_cookie = require("./utils/cookie");
class Context {
  constructor(req, options) {
    this.env = {};
    this.finalized = false;
    this.error = void 0;
    this._status = 200;
    this._pretty = false;
    this._prettySpace = 2;
    this._headers = void 0;
    this._preparedHeaders = void 0;
    this._path = "/";
    this.notFoundHandler = () => new Response();
    this.header = (name, value, options) => {
      if (options?.append) {
        if (!this._headers) {
          this._headers = new Headers(this._preparedHeaders);
          this._preparedHeaders = {};
        }
        this._headers.append(name, value);
      } else {
        if (this._headers) {
          this._headers.set(name, value);
        } else {
          this._preparedHeaders ?? (this._preparedHeaders = {});
          this._preparedHeaders[name.toLowerCase()] = value;
        }
      }
      if (this.finalized) {
        if (options?.append) {
          this.res.headers.append(name, value);
        } else {
          this.res.headers.set(name, value);
        }
      }
    };
    this.status = (status) => {
      this._status = status;
    };
    this.set = (key, value) => {
      this._map || (this._map = {});
      this._map[key] = value;
    };
    this.get = (key) => {
      return this._map?.[key];
    };
    this.pretty = (prettyJSON, space = 2) => {
      this._pretty = prettyJSON;
      this._prettySpace = space;
    };
    this.newResponse = (data, arg, headers) => {
      if (!headers && !this._headers && !this._res && !arg && this._status === 200) {
        return new Response(data, {
          headers: this._preparedHeaders
        });
      }
      if (arg && typeof arg !== "number") {
        const res = new Response(data, arg);
        const contentType = this._preparedHeaders?.["content-type"];
        if (contentType) {
          res.headers.set("content-type", contentType);
        }
        return res;
      }
      const status = arg ?? this._status;
      this._preparedHeaders ?? (this._preparedHeaders = {});
      this._headers ?? (this._headers = new Headers());
      for (const [k, v] of Object.entries(this._preparedHeaders)) {
        this._headers.set(k, v);
      }
      if (this._res) {
        this._res.headers.forEach((v, k) => {
          this._headers?.set(k, v);
        });
        for (const [k, v] of Object.entries(this._preparedHeaders)) {
          this._headers.set(k, v);
        }
      }
      headers ?? (headers = {});
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          this._headers.set(k, v);
        } else {
          this._headers.delete(k);
          for (const v2 of v) {
            this._headers.append(k, v2);
          }
        }
      }
      return new Response(data, {
        status,
        headers: this._headers
      });
    };
    this.body = (data, arg, headers) => {
      return typeof arg === "number" ? this.newResponse(data, arg, headers) : this.newResponse(data, arg);
    };
    this.text = (text, arg, headers) => {
      if (!this._preparedHeaders) {
        if (!headers && !this._res && !this._headers && !arg) {
          return new Response(text);
        }
        this._preparedHeaders = {};
      }
      if (this._preparedHeaders["content-type"]) {
        this._preparedHeaders["content-type"] = "text/plain; charset=UTF8";
      }
      return typeof arg === "number" ? this.newResponse(text, arg, headers) : this.newResponse(text, arg);
    };
    this.json = (object, arg, headers) => {
      const body = this._pretty ? JSON.stringify(object, null, this._prettySpace) : JSON.stringify(object);
      this._preparedHeaders ?? (this._preparedHeaders = {});
      this._preparedHeaders["content-type"] = "application/json; charset=UTF-8";
      return typeof arg === "number" ? this.newResponse(body, arg, headers) : this.newResponse(body, arg);
    };
    this.jsonT = (object, arg, headers) => {
      return {
        response: typeof arg === "number" ? this.json(object, arg, headers) : this.json(object, arg),
        data: object,
        format: "json"
      };
    };
    this.html = (html, arg, headers) => {
      this._preparedHeaders ?? (this._preparedHeaders = {});
      this._preparedHeaders["content-type"] = "text/html; charset=UTF-8";
      return typeof arg === "number" ? this.newResponse(html, arg, headers) : this.newResponse(html, arg);
    };
    this.redirect = (location, status = 302) => {
      this._headers ?? (this._headers = new Headers());
      this._headers.set("Location", location);
      return this.newResponse(null, status);
    };
    this.cookie = (name, value, opt) => {
      const cookie = (0, import_cookie.serialize)(name, value, opt);
      this.header("set-cookie", cookie, { append: true });
    };
    this.notFound = () => {
      return this.notFoundHandler(this);
    };
    this.rawRequest = req;
    if (options) {
      this._executionCtx = options.executionCtx;
      this._path = options.path ?? "/";
      this._paramData = options.paramData;
      this.env = options.env;
      if (options.notFoundHandler) {
        this.notFoundHandler = options.notFoundHandler;
      }
    }
  }
  get req() {
    if (this._req) {
      return this._req;
    } else {
      this._req = new import_request.HonoRequest(this.rawRequest, this._path, this._paramData);
      this.rawRequest = void 0;
      this._paramData = void 0;
      return this._req;
    }
  }
  get event() {
    if (this._executionCtx instanceof FetchEvent) {
      return this._executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this._executionCtx) {
      return this._executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this._res || (this._res = new Response("404 Not Found", { status: 404 }));
  }
  set res(_res) {
    if (this._res && _res) {
      this._res.headers.delete("content-type");
      this._res.headers.forEach((v, k) => {
        _res.headers.set(k, v);
      });
    }
    this._res = _res;
    this.finalized = true;
  }
  get runtime() {
    const global = globalThis;
    if (global?.Deno !== void 0) {
      return "deno";
    }
    if (global?.Bun !== void 0) {
      return "bun";
    }
    if (typeof global?.WebSocketPair === "function") {
      return "workerd";
    }
    if (typeof global?.EdgeRuntime === "string") {
      return "edge-light";
    }
    let onFastly = false;
    try {
      const { env } = require("fastly:env");
      if (env instanceof Function)
        onFastly = true;
    } catch {
    }
    if (onFastly) {
      return "fastly";
    }
    if (global?.__lagon__ !== void 0) {
      return "lagon";
    }
    if (global?.process?.release?.name === "node") {
      return "node";
    }
    return "other";
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Context
});
